diff --git a/src/db_session.hpp b/src/db_session.hpp
index 5e2aa73..13ea1bd 100644
--- a/src/db_session.hpp
+++ b/src/db_session.hpp
@@ -81,7 +81,13 @@ private:
       code_type, ranges_size> ranges_;
 
    // Seconds since epoch.
-   date_type last_post_date_ {0};
+   date_type post_deadline_ {0};
+
+   // The number of allowed posts until the deadline.
+   int n_allowed_posts_ = 0;
+
+   // The number of posts the user can publish until the deadline.
+   int n_remaining_posts_ = 0;
 
    Derived& derived() { return static_cast<Derived&>(*this); }
 
@@ -396,11 +402,27 @@ public:
    auto is_logged_in() const noexcept
       { return !std::empty(user_id_);};
 
-   void set_last_post_date(date_type date) noexcept
-      { last_post_date_ = date; }
+   void set_post_deadline(
+      int n_allowed_posts,
+      int n_remaining_posts,
+      date_type deadline) noexcept
+   {
+      post_deadline_ = deadline;
+      n_allowed_posts_ = n_allowed_posts;
+      n_remaining_posts_ = n_remaining_posts;
+   }
+
+   auto get_post_deadline() const noexcept
+      { return post_deadline_; }
+
+   auto get_allowed_posts() const noexcept
+      { return n_allowed_posts_; }
+
+   auto get_remaining_posts() const noexcept
+      { return n_remaining_posts_; }
 
-   auto get_last_post_date() const noexcept
-      { return last_post_date_; }
+   auto decrease_remaining_posts() noexcept
+      { return --n_remaining_posts_; }
 };
 
 }
diff --git a/src/db_worker.hpp b/src/db_worker.hpp
index 87e1ec0..019c6ad 100644
--- a/src/db_worker.hpp
+++ b/src/db_worker.hpp
@@ -26,8 +26,8 @@
 #include "channel.hpp"
 #include "db_session.hpp"
 #include "acceptor_mgr.hpp"
-#include "db_plain_session.hpp"
 #include "db_ssl_session.hpp"
+#include "db_plain_session.hpp"
 
 namespace rt
 {
@@ -429,13 +429,14 @@ private:
 
       using namespace std::chrono;
 
-      auto const date =
+      auto const now =
          duration_cast<seconds>(system_clock::now().time_since_epoch());
 
-      // App posts are also restricted in posts/day.
-      auto const d = s->get_last_post_date() + core_cfg_.get_post_interval();
-      if (d > date) {
-         // They are trying to publish too early.
+      // Since the deadline is always updated on expiration, this assert
+      // should always hold.
+      assert(now < s->get_post_deadline());
+
+      if (s->get_remaining_posts() < 1) {
          json resp;
          resp["cmd"] = "publish_ack";
          resp["result"] = "fail";
@@ -446,7 +447,7 @@ private:
       // It is important not to thrust the *from* field in the json
       // command.
       items.front().from = s->get_id();
-      items.front().date = date;
+      items.front().date = now;
       post_queue_.push({s, items.front()});
       db_.request_post_id();
       return ev_res::publish_ok;
@@ -802,13 +803,11 @@ private:
       auto ack_str = ack.dump();
 
       if (auto s = post_queue_.front().session.lock()) {
-         using namespace std::chrono;
          s->send(std::move(ack_str), true);
-         s->set_last_post_date(post_queue_.front().item.date);
 
-         db_.update_last_post_timestamp(
+         db_.update_remaining(
             s->get_id(),
-            post_queue_.front().item.date);
+            s->decrease_remaining_posts());
 
       } else {
          // If we get here the user is not online anymore. This should be a
@@ -854,6 +853,7 @@ private:
 
    void on_db_user_id(std::string const& id)
    {
+      using namespace std::chrono;
       assert(!std::empty(reg_queue_));
 
       while (!std::empty(reg_queue_)) {
@@ -863,7 +863,15 @@ private:
             // A hashed version of the password is stored in the
             // database.
             auto const digest = make_hex_digest(reg_queue_.front().pwd);
-            db_.register_user(id, digest);
+
+            auto const now =
+               duration_cast<seconds>(system_clock::now()
+                  .time_since_epoch());
+
+            auto const deadline = now + core_cfg_.get_post_interval();
+
+            // TODO: Replace 1 below with the value read from the database.
+            db_.register_user(id, digest, 1, deadline);
             session->set_id(id);
             return;
          }
@@ -907,7 +915,7 @@ private:
    {
       try {
          assert(!std::empty(login_queue_));
-         assert(std::size(fields) == 2);
+         assert(std::size(fields) == 4);
 
          if (auto s = login_queue_.front().session.lock()) {
             auto const digest = make_hex_digest(login_queue_.front().pwd);
@@ -948,13 +956,34 @@ private:
                   ss.first->second = s;
                }
 
-               // The string containing the timestamp in the database
-               // is stored in seconds.
-               auto const timestamp = std::stol(fields[1]);
-               s->set_last_post_date(std::chrono::seconds {timestamp});
+               using namespace std::chrono;
+               auto const n_allowed = std::stoi(fields.at(1));
+               auto const n_remaining = std::stoi(fields.at(2));
+               auto const deadline = seconds {std::stol(fields.at(3))};
+
+               s->set_post_deadline( n_allowed
+                                   , n_remaining
+                                   , deadline);
+
                db_.on_user_online(s->get_id());
                db_.retrieve_chat_msgs(s->get_id());
 
+               auto const now = duration_cast<seconds>(
+                  system_clock::now().time_since_epoch());
+
+               if (now > deadline) {
+                  // TODO: If the user logs in and his post deadline is
+                  // reached shortly afterwards, he won't be able to post
+                  // until he log in again. To overcome this we can update
+                  // the deadline with some precedence, say be introducing
+                  // a margin os time that is close the average value of
+                  // websocket sessions.
+                  db_.update_post_deadline(
+                        s->get_id(),
+                        n_allowed,
+                        now + core_cfg_.get_post_interval());
+               }
+
                json resp;
                resp["cmd"] = "login_ack";
                resp["result"] = "ok";
@@ -965,7 +994,8 @@ private:
             // Very unlikely to happen since the communication with redis is
             // very fast.
          }
-      } catch (...) {
+      } catch (std::exception const& e) {
+         log(loglevel::crit, "on_user_data: {0}", e.what());
       }
 
       login_queue_.pop();
diff --git a/src/redis.cpp b/src/redis.cpp
index 7f25729..3cdae7a 100644
--- a/src/redis.cpp
+++ b/src/redis.cpp
@@ -280,13 +280,19 @@ void redis::request_user_id()
    menu_pub_queue.push(events::user_id);
 }
 
-void redis::register_user(std::string const& user, std::string const& pwd)
+void
+redis::register_user( std::string const& user
+                    , std::string const& pwd
+                    , int n_allowed_posts
+                    , std::chrono::seconds deadline)
 {
    auto const key =  cfg_.user_data_prefix_key + user;
 
    std::initializer_list<std::string const> const par
    { "password",  pwd
-   , "last_post", "0"
+   , "allowed", std::to_string(n_allowed_posts)
+   , "remaining", std::to_string(n_allowed_posts)
+   , "deadline", std::to_string(deadline.count())
    };
 
    ss_menu_pub.send(hset(key, par));
@@ -296,19 +302,37 @@ void redis::register_user(std::string const& user, std::string const& pwd)
 void redis::retrieve_user_data(std::string const& user)
 {
    auto const key =  cfg_.user_data_prefix_key + user;
-   ss_menu_pub.send(hmget(key, "password", "last_post"));
+   ss_menu_pub.send(hmget(key, "password", "allowed", "remaining", "deadline"));
    menu_pub_queue.push(events::user_data);
 }
 
 void
-redis::update_last_post_timestamp( std::string const& user
-                                  , std::chrono::seconds secs)
+redis::update_post_deadline( std::string const& user
+                           , int n_allowed_posts
+                           , std::chrono::seconds deadline)
 {
    auto const key =  cfg_.user_data_prefix_key + user;
-   std::initializer_list<std::string const> const l =
-   { "last_post", std::to_string(secs.count())};
+
+   std::initializer_list<std::string const> l =
+   { "allowed", std::to_string(n_allowed_posts)
+   , "remaining", std::to_string(n_allowed_posts)
+   , "deadline", std::to_string(deadline.count())};
+
    ss_menu_pub.send(hset(key, l));
-   menu_pub_queue.push(events::last_post_timestamp);
+   menu_pub_queue.push(events::update_post_deadline);
+}
+
+void
+redis::update_remaining( std::string const& user_id
+                       , int remaining)
+{
+   auto const key =  cfg_.user_data_prefix_key + user_id;
+
+   std::initializer_list<std::string const> l =
+   { "remaining", std::to_string(remaining)};
+
+   ss_menu_pub.send(hset(key, l));
+   menu_pub_queue.push(events::ignore);
 }
 
 void redis::retrieve_posts(int begin)
diff --git a/src/redis.hpp b/src/redis.hpp
index 0b18a76..7d3a265 100644
--- a/src/redis.hpp
+++ b/src/redis.hpp
@@ -28,7 +28,7 @@ public:
    , remove_post
    , get_chat_msgs
    , presence
-   , last_post_timestamp
+   , update_post_deadline
    , ignore
    };
 
@@ -175,7 +175,7 @@ public:
    //    redis::events::chat_messages
    //
    // Additionaly, this function also subscribes the worker to
-   // presence messages, which complete with
+   // presence messages, which completes with
    // 
    //    redis::events::presence
    //
@@ -258,8 +258,14 @@ public:
    // Register a user in the database. Completes with
    //
    //    redis::events::register_user
-   //           
-   void register_user(std::string const& user, std::string const& pwd);
+   //
+   // n_allowed_posts is the number of posts the user is allowed to publish
+   // until the deadline.
+   void
+   register_user( std::string const& user
+                , std::string const& pwd
+                , int n_allowed_posts
+                , std::chrono::seconds deadline);
 
    // Retrieves the user password (and possibly other data in the
    // future) from the database. Completes with 
@@ -270,11 +276,20 @@ public:
 
    // Updates the user last post timestamp. Completes with
    //
-   //   redis::events::last_post_timestamp
+   //   redis::events::update_post_deadline
+   //
+   void
+   update_post_deadline( std::string const& user_id
+                       , int n_allowed_posts
+                       , std::chrono::seconds deadline);
+
+   // Updates the number of remaining posts. Completes with
+   //
+   //   redis::events::ignore
    //
    void
-   update_last_post_timestamp( std::string const& user_id
-                             , std::chrono::seconds secs);
+   update_remaining( std::string const& user_id
+                   , int remaining);
 
    // Closes all stablished connections with redis.
    void disconnect();
